class API(object):
    def __init__(self, url, username, password, key_file=None, cert_file=None,
                 ca_file=None, port=None, timeout=None, session_timeout=None, persistent_auth=True,
                 renew_session=False, insecure=False, validate_cert_chain=True, filter=False, debug=False):  # @ReservedAssignment

        '''
        @param url: server url (format "http/s://server[:port]/ovirt-engine/api")
        @param username: user (format user@domain)
        @param password: password
        [@param key_file: client PEM key_file for ssl enabled connection]
        [@param cert_file: client PEM cert_file for ssl enabled connection]
        [@param ca_file: server ca_file for ssl enabled connection]
        [@param port: port to use (if not specified in url)]
        [@param timeout: request timeout]
        [@param session_timeout: authentication session timeout in minutes (if persistent_auth is enabled)]
        [@param persistent_auth: use persistent authentication (default is True)]
        [@param renew_session: automatically renew expired authentication session (default is False)]
        [@param insecure: signals to not demand site trustworthiness for ssl enabled connection (default is False)]
        [@param validate_cert_chain: validate the server's CA certificate (default is True)]
        [@param filter: enables user-api filtering (default is False)]
        [@param debug: debug (format True|False)]

        @raise NoCertificatesError: raised when CA certificate is not provided for SSL site (can be disabled using 'insecure=True' argument).
        @raise UnsecuredConnectionAttemptError: raised when HTTP protocol is used in url against server running HTTPS.
        @raise ImmutableError: raised on sdk < 3.2 when sdk initiation attempt occurred while sdk instance already exist under the same domain.
        @raise DisconnectedError: raised when sdk usage attempt occurred after it was explicitly disconnected.
        @raise MissingParametersError: raised when get() method invoked without id or name been specified.
        @raise ConnectionError: raised when any kind of communication error occurred.
        @raise RequestError: raised when any kind of oVirt server error occurred.
        @raise FormatError: raised when server replies in non-XML format.
        '''

        # The instance id
        self.__id = id(self)

        # Implicitly disconnect and perform cleanup
        # when detected instance of the SDK proxy with
        # ref-count == 0
        if context.manager.has_key(self.__id):
            try:
                self.disconnect()
            except DisconnectedError:
                pass

        # Remove trailing slashes from the URL:
        url = url.rstrip('/')

        # For backwards compatibility we need to support URLs that don't
        # contain a path, and in that case the path should be the old /api:
        prefix = urlparse.urlparse(url).path
        if prefix == '':
            prefix = '/api'
            url = url + prefix

        # Create the connection pool:
        pool = ConnectionsPool(
            url=url,
            username=username,
            password=password,
            context=self.id,
            key_file=key_file,
            cert_file=cert_file,
            ca_file=ca_file,
            port=port,
            strict=False,
            timeout=timeout,
            insecure=insecure,
            validate_cert_chain=validate_cert_chain,
            debug=debug
        )

        # Create the proxy:
        proxy = Proxy(
            pool,
            persistent_auth,
            prefix
        )

        # Store filter to the context:
        self.set_filter(filter)

        # We need to remember if renew_session is enabled:
        self.set_renew_session(renew_session)

        # Store session_timeout to the context:
        self.__set_session_timeout(session_timeout)

        # Get entry point
        entry_point = proxy.request(
            method='GET',
            url=''
        )

        # If server returns no response for the root resource, this is sign
        # that used http protocol against SSL secured site
        if type(entry_point) == types.StringType and entry_point == '':
            raise UnsecuredConnectionAttemptError

        # Store entry point to the context
        context.manager[self.id].add(
            'entry_point',
            entry_point,
            Mode.R
        )

        # Store proxy to the context:
        context.manager[self.id].add(
            'proxy',
            proxy,
            Mode.R
        )

        # We need to remember if persistent auth is enabled:
        context.manager[self.id].add(
            'persistent_auth',
             persistent_auth,
             Mode.R,
             typ=types.BooleanType
        )

